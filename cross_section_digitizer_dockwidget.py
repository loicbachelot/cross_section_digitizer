# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CrossSectionDigitizerDockWidget
                                 A QGIS plugin
 digitizer and georeferencer for 1D and 2D subsurface data 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-18
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cascadia Regional Earthquake Science Center (CRESCENT)
        email                : crescentcfm@cascadiaquakes.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import csv
import math
import json

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QPointF
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox, QSplitter, QAction
from qgis.core import (QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, 
                       QgsLineString, QgsPolygon,
                       QgsPoint, QgsField, QgsFields)
from qgis.PyQt.QtCore import QVariant

# Import the new image viewer widget
from .image_viewer_widget import ImageViewerWidget

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'cross_section_digitizer_dockwidget_base.ui'))


class CrossSectionDigitizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(CrossSectionDigitizerDockWidget, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        
        # Set window flags to keep widget on top and visible
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        
        # Initialize variables
        self.image_path = None
        self.reference_points = {}  # {origin: (pixel_x, pixel_y), x_ref: (pixel_x, pixel_y), y_ref: (pixel_x, pixel_y)}
        self.plot_georef_points = {}  # {start_plot: (plot_x, plot_y), end_plot: (plot_x, plot_y)}
        self.data_series = {}  # {series_name: [(x, y), ...]}
        self.current_series = None
        self.digitizing_mode = None  # 'origin', 'x_ref', 'y_ref', 'points', 'start_plot', 'end_plot'
        
        # Create and setup the image viewer
        self.setup_image_viewer()
        
        # Connect signals
        self.setup_connections()
        
    def setup_image_viewer(self):
        """Setup the image viewer widget"""
        # Create the image viewer
        self.image_viewer = ImageViewerWidget()
        
        # Insert the image viewer into the main layout
        # We'll add it as the first widget in the vertical layout
        main_layout = self.dockWidgetContents.layout()
        
        # Create a splitter to allow resizing between viewer and controls
        self.splitter = QSplitter(Qt.Vertical)
        
        # Make the splitter handle more visible
        self.splitter.setHandleWidth(5)
        self.update_splitter_style()
        
        # Add image viewer to splitter
        self.splitter.addWidget(self.image_viewer)
        
        # Move the tab widget to the splitter
        main_layout.removeWidget(self.tabWidget)
        self.splitter.addWidget(self.tabWidget)
        
        # Set initial sizes (80% viewer, 20% controls)
        self.splitter.setSizes([560, 140])
        
        # Don't collapse widgets when resizing
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        
        # Add splitter to main layout
        main_layout.insertWidget(0, self.splitter)
        
        # Add orientation toggle button to the image viewer toolbar
        self.add_orientation_toggle()
        
        # Connect image viewer signals
        self.image_viewer.mouseClicked.connect(self.handle_image_click)
        
    def update_splitter_style(self):
        """Update splitter style based on orientation"""
        if self.splitter.orientation() == Qt.Vertical:
            self.splitter.setStyleSheet("""
                QSplitter::handle {
                    background-color: #d0d0d0;
                    border: 1px solid #a0a0a0;
                }
                QSplitter::handle:hover {
                    background-color: #b0b0b0;
                }
                QSplitter::handle:vertical {
                    height: 5px;
                }
            """)
        else:
            self.splitter.setStyleSheet("""
                QSplitter::handle {
                    background-color: #d0d0d0;
                    border: 1px solid #a0a0a0;
                }
                QSplitter::handle:hover {
                    background-color: #b0b0b0;
                }
                QSplitter::handle:horizontal {
                    width: 5px;
                }
            """)
            
    def add_orientation_toggle(self):
        """Add button to toggle control panel orientation"""
        # Add a separator before our button
        self.image_viewer.toolbar.addSeparator()
        
        # Create orientation toggle action
        self.action_toggle_orientation = QAction("Toggle Panel Position", self)
        self.action_toggle_orientation.setToolTip("Move control panel to bottom/right")
        self.action_toggle_orientation.triggered.connect(self.toggle_orientation)
        self.image_viewer.toolbar.addAction(self.action_toggle_orientation)
        
    def toggle_orientation(self):
        """Toggle between vertical and horizontal splitter orientation"""
        # Get current sizes to maintain proportions
        sizes = self.splitter.sizes()
        total = sum(sizes)
        
        if self.splitter.orientation() == Qt.Vertical:
            # Switch to horizontal (controls on right)
            self.splitter.setOrientation(Qt.Horizontal)
            # Adjust sizes for horizontal layout - give more space to viewer
            if total > 0:
                viewer_size = int(total * 0.75)  # 75% for viewer
                control_size = total - viewer_size  # 25% for controls
                self.splitter.setSizes([viewer_size, control_size])
        else:
            # Switch to vertical (controls on bottom)
            self.splitter.setOrientation(Qt.Vertical)
            # Adjust sizes for vertical layout
            if total > 0:
                viewer_size = int(total * 0.80)  # 80% for viewer
                control_size = total - viewer_size  # 20% for controls
                self.splitter.setSizes([viewer_size, control_size])
        
        # Update splitter style for new orientation
        self.update_splitter_style()
        
        # Update button tooltip
        if self.splitter.orientation() == Qt.Vertical:
            self.action_toggle_orientation.setToolTip("Move control panel to right")
        else:
            self.action_toggle_orientation.setToolTip("Move control panel to bottom")
        
    def setup_connections(self):
        """Connect UI signals to methods"""
        # Image tab
        self.btn_load_image.clicked.connect(self.load_image)
        self.btn_set_origin.clicked.connect(lambda: self.start_reference_mode('origin'))
        self.btn_set_x_ref.clicked.connect(lambda: self.start_reference_mode('x_ref'))
        self.btn_set_y_ref.clicked.connect(lambda: self.start_reference_mode('y_ref'))
        self.btn_validate_reference.clicked.connect(self.validate_reference_points)
        self.btn_clear_reference.clicked.connect(self.clear_reference_points)
        self.btn_export_reference.clicked.connect(self.export_georeference_info)
        self.btn_import_reference.clicked.connect(self.import_georeference_info)
        
        # Digitize tab
        self.btn_new_series.clicked.connect(self.create_new_series)
        self.combo_series.currentTextChanged.connect(self.select_series)
        self.btn_digitize_points.clicked.connect(self.start_digitizing_points)
        self.btn_delete_point.clicked.connect(self.delete_selected_point)
        self.btn_save_series.clicked.connect(self.save_series_to_file)
        
        # Georeference tab
        self.btn_set_start_plot.clicked.connect(lambda: self.start_plot_georef_mode('start_plot'))
        self.btn_set_end_plot.clicked.connect(lambda: self.start_plot_georef_mode('end_plot'))
        self.btn_clear_plot_points.clicked.connect(self.clear_plot_georef_points)
        self.btn_create_polygon.clicked.connect(self.create_georeferenced_polygon)
        self.btn_georeference_points.clicked.connect(self.georeference_digitized_points)
        self.btn_export_georeference.clicked.connect(self.export_georeference_info)
        self.btn_import_georeference.clicked.connect(self.import_georeference_info)
        
    def load_image(self):
        """Load raster image for digitizing"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Load Image", "", 
            "Image Files (*.png *.jpg *.jpeg *.tif *.tiff *.bmp)")
        
        if file_path:
            # Load image into the viewer
            if self.image_viewer.load_image(file_path):
                self.image_path = file_path
                layer_name = os.path.basename(file_path)
                self.label_image_path.setText(f"Loaded: {layer_name}")
                
                # Clear any existing markers
                self.clear_all_markers()
            else:
                QMessageBox.warning(self, "Error", "Failed to load image")
                
    def start_reference_mode(self, mode):
        """Start reference point selection mode"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        self.digitizing_mode = mode
        # Enable digitize mode in the viewer
        self.image_viewer.action_digitize.setChecked(True)
        self.image_viewer.toggle_digitize_mode(True)
        
        mode_names = {'origin': 'origin point', 'x_ref': 'X reference point', 'y_ref': 'Y reference point'}
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", 
            f"Click on the image to set the {mode_names[mode]}", 
            level=0, duration=3)
            
    def start_plot_georef_mode(self, mode):
        """Start plot georeferencing point selection mode"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all reference points first")
            return
            
        self.digitizing_mode = mode
        # Enable digitize mode in the viewer
        self.image_viewer.action_digitize.setChecked(True)
        self.image_viewer.toggle_digitize_mode(True)
        
        mode_names = {'start_plot': 'start point', 'end_plot': 'end point'}
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", 
            f"Click on the plot to set the cross-section {mode_names[mode]}", 
            level=0, duration=3)
            
    def clear_plot_georef_points(self):
        """Clear plot georeferencing points"""
        self.plot_georef_points.clear()
        self.image_viewer.clear_georef_markers()
        self.spin_start_plot_x.setValue(0)
        self.spin_start_plot_y.setValue(0)
        self.spin_end_plot_x.setValue(0)
        self.spin_end_plot_y.setValue(0)
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", "Plot georeferencing points cleared", level=0, duration=2)
            
    def handle_image_click(self, x, y, button):
        """Handle clicks on the image"""
        if button != Qt.LeftButton:
            return
            
        point = QPointF(x, y)
        
        if self.digitizing_mode in ['origin', 'x_ref', 'y_ref']:
            self.reference_points[self.digitizing_mode] = (x, y)
            
            # Add visual marker for reference point
            self.image_viewer.add_reference_marker(x, y, self.digitizing_mode)
            
            mode_messages = {
                'origin': f"Origin set at pixel ({x:.1f}, {y:.1f})",
                'x_ref': f"X reference set at pixel ({x:.1f}, {y:.1f})",
                'y_ref': f"Y reference set at pixel ({x:.1f}, {y:.1f})"
            }
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                mode_messages[self.digitizing_mode], 
                level=0, duration=2)
                
            # Reset digitizing mode
            self.digitizing_mode = None
            self.image_viewer.action_digitize.setChecked(False)
            self.image_viewer.toggle_digitize_mode(False)
            
        elif self.digitizing_mode in ['start_plot', 'end_plot']:
            # Convert pixel coordinates to plot coordinates
            plot_coords = self.pixel_to_plot_coords(x, y)
            if plot_coords:
                self.plot_georef_points[self.digitizing_mode] = plot_coords
                
                # Add visual marker for georeferencing point
                self.image_viewer.add_georef_marker(x, y)
                
                # Update the appropriate spinboxes
                if self.digitizing_mode == 'start_plot':
                    self.spin_start_plot_x.setValue(plot_coords[0])
                    self.spin_start_plot_y.setValue(plot_coords[1])
                    point_name = "start"
                else:  # end_plot
                    self.spin_end_plot_x.setValue(plot_coords[0])
                    self.spin_end_plot_y.setValue(plot_coords[1])
                    point_name = "end"
                    
                self.iface.messageBar().pushMessage(
                    "CrossSectionDigitizer", 
                    f"Cross-section {point_name} point set at ({plot_coords[0]:.3f}, {plot_coords[1]:.3f})", 
                    level=0, duration=2)
                    
                # Reset digitizing mode
                self.digitizing_mode = None
                self.image_viewer.action_digitize.setChecked(False)
                self.image_viewer.toggle_digitize_mode(False)
            
        elif self.digitizing_mode == 'points' and self.current_series:
            # Convert pixel coordinates to plot coordinates
            plot_coords = self.pixel_to_plot_coords(x, y)
            if plot_coords:
                self.data_series[self.current_series].append(plot_coords)
                
                # Add visual marker for data point
                self.image_viewer.add_data_marker(x, y, self.current_series, is_active=True)
                
                self.update_points_list()
                
    def pixel_to_plot_coords(self, pixel_x, pixel_y):
        """Convert pixel coordinates to plot coordinates using reference points"""
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all three reference points first")
            return None
            
        origin_px, origin_py = self.reference_points['origin']
        x_ref_px, x_ref_py = self.reference_points['x_ref']
        y_ref_px, y_ref_py = self.reference_points['y_ref']
        
        # Get reference values from spinboxes
        origin_x = self.spin_origin_x.value()
        origin_y = self.spin_origin_y.value()
        x_ref_val = self.spin_x_ref.value()
        y_ref_val = self.spin_y_ref.value()
        
        # Calculate scale factors
        x_scale = (x_ref_val - origin_x) / (x_ref_px - origin_px) if x_ref_px != origin_px else 1
        y_scale = (y_ref_val - origin_y) / (y_ref_py - origin_py) if y_ref_py != origin_py else 1
        
        # Transform pixel coordinates to plot coordinates
        plot_x = origin_x + (pixel_x - origin_px) * x_scale
        plot_y = origin_y + (pixel_y - origin_py) * y_scale
        
        return (plot_x, plot_y)
        
    def plot_to_pixel_coords(self, plot_x, plot_y):
        """Convert plot coordinates back to pixel coordinates (reverse transformation)"""
        if len(self.reference_points) < 3:
            return None
            
        origin_px, origin_py = self.reference_points['origin']
        x_ref_px, x_ref_py = self.reference_points['x_ref']
        y_ref_px, y_ref_py = self.reference_points['y_ref']
        
        # Get reference values from spinboxes
        origin_x = self.spin_origin_x.value()
        origin_y = self.spin_origin_y.value()
        x_ref_val = self.spin_x_ref.value()
        y_ref_val = self.spin_y_ref.value()
        
        # Calculate scale factors
        x_scale = (x_ref_val - origin_x) / (x_ref_px - origin_px) if x_ref_px != origin_px else 1
        y_scale = (y_ref_val - origin_y) / (y_ref_py - origin_py) if y_ref_py != origin_py else 1
        
        # Reverse transform plot coordinates to pixel coordinates
        if x_scale != 0 and y_scale != 0:
            pixel_x = origin_px + (plot_x - origin_x) / x_scale
            pixel_y = origin_py + (plot_y - origin_y) / y_scale
            return (pixel_x, pixel_y)
        return None
        
    def validate_reference_points(self):
        """Validate that all reference points and values are set"""
        missing = []

        # Check if image is loaded
        if not self.image_path:
            missing.append("- No image loaded")

        # Check reference points
        if 'origin' not in self.reference_points:
            missing.append("- Origin point not set (click 'Set Origin' button)")
        else:
            # Check origin values
            if self.spin_origin_x.value() == 0 and self.spin_origin_y.value() == 0:
                missing.append("- Origin X,Y values not set (enter values in spinboxes)")

        if 'x_ref' not in self.reference_points:
            missing.append("- X reference point not set (click 'Set X Reference Point' button)")
        else:
            # Check X reference value
            if self.spin_x_ref.value() == 0:
                missing.append("- X reference value not set (enter value in spinbox)")

        if 'y_ref' not in self.reference_points:
            missing.append("- Y reference point not set (click 'Set Y Reference Point' button)")
        else:
            # Check Y reference value  
            if self.spin_y_ref.value() == 0:
                missing.append("- Y reference value not set (enter value in spinbox)")

        # Show results
        if missing:
            msg = "Reference points validation failed. Missing:\n\n" + "\n".join(missing)
            QMessageBox.warning(self, "Validation Failed", msg)
        else:
            # Additional validation - check if points are not collinear
            if len(self.reference_points) == 3:
                origin = self.reference_points['origin']
                x_ref = self.reference_points['x_ref']
                y_ref = self.reference_points['y_ref']

                # Check if points form a valid coordinate system
                # Calculate vectors
                vx = (x_ref[0] - origin[0], x_ref[1] - origin[1])
                vy = (y_ref[0] - origin[0], y_ref[1] - origin[1])

                # Check if vectors are too parallel (cross product close to zero)
                cross = abs(vx[0] * vy[1] - vx[1] * vy[0])
                if cross < 10:  # threshold in pixels
                    QMessageBox.warning(self, "Validation Warning", 
                        "Reference points appear to be nearly collinear.\n"
                        "This may result in poor coordinate transformation.\n"
                        "Consider repositioning the reference points.")
                else:
                    # Validation successful - enable coordinate transformation
                    self.image_viewer.set_coordinate_transform_callback(self.pixel_to_plot_coords)
                    QMessageBox.information(self, "Validation Successful", 
                        "All reference points and values are properly set!\n"
                        "You can now proceed to digitize points.\n"
                        "Plot coordinates will now be displayed in the status bar.")

    def clear_reference_points(self):
        """Clear all reference points"""
        self.reference_points.clear()
        self.image_viewer.clear_reference_markers()

        # Disable coordinate transformation
        self.image_viewer.set_coordinate_transform_callback(None)

        # Reset spinbox values to 0
        self.spin_origin_x.setValue(0)
        self.spin_origin_y.setValue(0)
        self.spin_x_ref.setValue(0)
        self.spin_y_ref.setValue(0)

        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", "Reference points cleared", level=0, duration=2)
            
    def create_new_series(self):
        """Create a new data series"""
        series_name = self.line_series_name.text().strip()
        if not series_name:
            QMessageBox.warning(self, "Error", "Please enter a series name")
            return
            
        if series_name in self.data_series:
            QMessageBox.warning(self, "Error", "Series name already exists")
            return
            
        self.data_series[series_name] = []
        self.combo_series.addItem(series_name)
        self.combo_series.setCurrentText(series_name)
        self.current_series = series_name
        self.line_series_name.clear()
        
    def select_series(self, series_name):
        """Select current data series"""
        if series_name in self.data_series:
            self.current_series = series_name
            # Update marker colors based on active series
            self.image_viewer.update_series_colors(series_name)
            self.update_points_list()
            
    def start_digitizing_points(self):
        """Start digitizing points mode"""
        if not self.current_series:
            QMessageBox.warning(self, "Error", "Please create or select a data series first")
            return
            
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all reference points first")
            return
        
        # Toggle digitizing mode based on button state
        if self.btn_digitize_points.isChecked():
            self.digitizing_mode = 'points'
            # Enable digitize mode in the viewer
            self.image_viewer.action_digitize.setChecked(True)
            self.image_viewer.toggle_digitize_mode(True)
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                "Click on points to digitize. Click 'Start Digitizing Points' again to stop.", 
                level=0, duration=5)
        else:
            # Stop digitizing
            self.digitizing_mode = None
            self.image_viewer.action_digitize.setChecked(False)
            self.image_viewer.toggle_digitize_mode(False)
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                "Digitizing stopped.", 
                level=0, duration=2)
            
    def update_points_list(self):
        """Update the points list widget"""
        self.list_points.clear()
        if self.current_series and self.current_series in self.data_series:
            for i, (x, y) in enumerate(self.data_series[self.current_series]):
                self.list_points.addItem(f"Point {i+1}: ({x:.3f}, {y:.3f})")
                
    def delete_selected_point(self):
        """Delete selected point from current series"""
        if not self.current_series or self.current_series not in self.data_series:
            return
            
        current_row = self.list_points.currentRow()
        if current_row >= 0:
            del self.data_series[self.current_series][current_row]
            
            # Clear and recreate markers for this series
            self.image_viewer.clear_series_markers(self.current_series)
            self.recreate_series_markers(self.current_series)
            
            self.update_points_list()
            
    def recreate_series_markers(self, series_name):
        """Recreate visual markers for a data series"""
        if series_name not in self.data_series:
            return
            
        is_active = (series_name == self.current_series)
        
        for plot_x, plot_y in self.data_series[series_name]:
            # Convert plot coordinates back to pixel coordinates for marker placement
            pixel_coords = self.plot_to_pixel_coords(plot_x, plot_y)
            if pixel_coords:
                self.image_viewer.add_data_marker(pixel_coords[0], pixel_coords[1], 
                                                 series_name, is_active)
            
    def save_series_to_file(self):
        """Save current series to CSV file"""
        if not self.current_series or not self.data_series[self.current_series]:
            QMessageBox.warning(self, "Error", "No data to save")
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Series", f"{self.current_series}.csv", "CSV Files (*.csv)")
            
        if file_path:
            with open(file_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['X', 'Y'])
                for x, y in self.data_series[self.current_series]:
                    writer.writerow([x, y])
            QMessageBox.information(self, "Success", f"Series saved to {file_path}")
            
    def create_georeferenced_polygon(self):
        """Create georeferenced polygon representing the cross-section"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        # Check if plot coordinates are set
        if 'start_plot' not in self.plot_georef_points or 'end_plot' not in self.plot_georef_points:
            QMessageBox.warning(self, "Error", "Please set start and end points on the plot first")
            return
            
        # Get georeferencing points
        start_lon = self.spin_start_lon.value()
        start_lat = self.spin_start_lat.value()
        start_elev = self.spin_start_elev.value()
        end_lon = self.spin_end_lon.value()
        end_lat = self.spin_end_lat.value()
        end_elev = self.spin_end_elev.value()
        
        if start_lon == 0 and start_lat == 0 and end_lon == 0 and end_lat == 0:
            QMessageBox.warning(self, "Error", "Please set georeferencing coordinates")
            return
            
        # Image plot coordinates
        #   pixel coordinates
        nx, nz = self.image_viewer.get_image_size()
        ul = (0,0)
        ur = (nx,0)
        ll = (0,nz)
        lr = (nx,nz)
        #   x-sec coordinates
        ul_xc = self.pixel_to_plot_coords(*ul)
        ur_xc = self.pixel_to_plot_coords(*ur)
        ll_xc = self.pixel_to_plot_coords(*ll)
        lr_xc = self.pixel_to_plot_coords(*lr)
        #   geog coordinates
        geog_coords = project_x_sec_pts_to_geog(
            (ul_xc[0], ur_xc[0], ll_xc[0], lr_xc[0]),
            (ul_xc[1], ur_xc[1], ll_xc[1], lr_xc[1]),
            (start_lon, start_lat, start_elev),
            (end_lon, end_lat, end_elev),
            z_unit="km",
            depth_pos=False
        )

        ul_geog, ur_geog, ll_geog, lr_geog = geog_coords
        
        # Create polygon layer
        layer = QgsVectorLayer("PolygonZ?crs=EPSG:4326", "Cross_Section_Polygon", "memory")
        provider = layer.dataProvider()
        
        # Add fields
        fields = QgsFields()
        fields.append(QgsField("name", QVariant.String))
        fields.append(QgsField("image_path", QVariant.String))
        provider.addAttributes(fields)
        layer.updateFields()
        
        
        # Create rectangle points
        rect_points = [
            QgsPoint(x=ul_geog[0], y=ul_geog[1], z=ul_geog[2]),
            QgsPoint(x=ur_geog[0], y=ur_geog[1], z=ur_geog[2]),
            QgsPoint(x=lr_geog[0], y=lr_geog[1], z=lr_geog[2]),
            QgsPoint(x=ll_geog[0], y=ll_geog[1], z=ll_geog[2]),
            QgsPoint(x=ul_geog[0], y=ul_geog[1], z=ul_geog[2]),
        ]

        # create point layer for debugging
        #pt_layer = QgsVectorLayer("PointZ?crs=EPSG:4326", "Image Corners", "memory")
        #pt_provider = pt_layer.dataProvider()
        #pt_fields = QgsFields()
        #pt_fields.append(QgsField("position", QVariant.String))
        #pt_provider.addAttributes(pt_fields)
        #pt_layer.updateFields()

        #field_names = ["ul", "ur", "lr", "ll"]
        #for i, pt in enumerate(rect_points[:4]):
        #    pt_ft = QgsFeature()
        #    pt_ft.setGeometry(QgsGeometry.fromPoint(pt))
        #    pt_ft.setAttributes(["position", field_names[i]])
        #    pt_provider.addFeatures([pt_ft])
        #    pt_layer.updateExtents()
        #    QMessageBox.information(self, "Success", f"{field_names[i]}, {pt_ft.geometry().asWkt()}")

        #QgsProject.instance().addMapLayer(pt_layer)
        
        
        # Create feature
        ring   = QgsLineString(rect_points)      # outer ring
        poly3d = QgsPolygon(ring)                # no interior rings for a rectangle
        geom   = QgsGeometry(poly3d)    

        feature = QgsFeature()
        feature.setGeometry(geom)
        feature.setAttributes([
            "Cross_Section", self.image_path,
        ])
        
        provider.addFeatures([feature])
        layer.updateExtents()
        
        # Add to project
        QgsProject.instance().addMapLayer(layer)
        QMessageBox.information(self, "Success", "Georeferenced polygon created")

        
        
    def georeference_digitized_points(self):
        """Georeference all digitized data series"""
        if not self.data_series:
            QMessageBox.warning(self, "Error", "No digitized data available")
            return
            
        # Check if plot coordinates are set
        if 'start_plot' not in self.plot_georef_points or 'end_plot' not in self.plot_georef_points:
            QMessageBox.warning(self, "Error", "Please set start and end points on the plot first")
            return
            
        # Get georeferencing parameters
        start_lon = self.spin_start_lon.value()
        start_lat = self.spin_start_lat.value()
        start_elev = self.spin_start_elev.value()
        end_lon = self.spin_end_lon.value()
        end_lat = self.spin_end_lat.value()
        end_elev = self.spin_end_elev.value()
        
        if start_lon == 0 and start_lat == 0 and end_lon == 0 and end_lat == 0:
            QMessageBox.warning(self, "Error", "Please set georeferencing coordinates")
            return
            
        # Create point layer for each series
        for series_name, points in self.data_series.items():
            if not points:
                continue
                
            # Create point layer
            layer = QgsVectorLayer("PointZ?crs=EPSG:4326", f"Georeferenced_{series_name}", "memory")
            provider = layer.dataProvider()
            
            # Add fields
            fields = QgsFields()
            fields.append(QgsField("series", QVariant.String))
            fields.append(QgsField("point_id", QVariant.Int))
            provider.addAttributes(fields)
            layer.updateFields()
            
            features = []
            for i, (plot_x, plot_y) in enumerate(points):
                georef_points = project_x_sec_pts_to_geog(
                    [plot_x], [plot_y],
                    (start_lon, start_lat, start_elev),
                    (end_lon, end_lat, end_elev),
                    z_unit="km",
                    depth_pos=False
                )
                
                if georef_points:
                    lon, lat, elev = georef_points[0]
                    
                    feature = QgsFeature()
                    #feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lon, lat)))
                    feature.setGeometry(QgsGeometry.fromPoint(QgsPoint(lon,lat,elev)))
                    feature.setAttributes([
                        series_name, i+1
                    ])
                    features.append(feature)
            
            if features:
                provider.addFeatures(features)
                layer.updateExtents()
                QgsProject.instance().addMapLayer(layer)
        
        QMessageBox.information(self, "Success", "Digitized points georeferenced and added to project")

    def clear_all_markers(self):
        """Clear all markers from the image viewer"""
        self.image_viewer.clear_reference_markers()
        self.image_viewer.clear_series_markers()
        self.image_viewer.clear_georef_markers()

    def export_georeference_info(self):
        """Export all georeferencing information to JSON"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Georeference Info", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        # Add .json extension if not present
        if not filename.lower().endswith('.json'):
            filename += '.json'
            
        try:
            # Build export data with combined format
            export_data = {
                "type": "cross_section_georeference_info",
                "version": "1.0",
                "image_path": getattr(self, 'image_path', ""),
                "reference_points": None,
                "plot_coordinates": None,
                "geographic_coordinates": None
            }
            
            # Add reference points if they exist
            if hasattr(self, 'reference_points') and self.reference_points:
                reference_points = {}
                for point_type, (pixel_x, pixel_y) in self.reference_points.items():
                    point_data = {
                        "pixel": [pixel_x, pixel_y]
                    }
                    
                    # Add plot coordinates based on point type
                    if point_type == 'origin':
                        point_data["plot"] = [
                            self.spin_origin_x.value(),
                            self.spin_origin_y.value()
                        ]
                    elif point_type == 'x_ref':
                        point_data["value"] = self.spin_x_ref.value()
                    elif point_type == 'y_ref':
                        point_data["value"] = self.spin_y_ref.value()
                        
                    reference_points[point_type] = point_data
                
                if reference_points:
                    export_data["reference_points"] = reference_points
            
            # Add plot coordinates if they exist
            if hasattr(self, 'plot_georef_points') and self.plot_georef_points:
                plot_coordinates = {}
                for point_type, (plot_x, plot_y) in self.plot_georef_points.items():
                    plot_coordinates[point_type] = [plot_x, plot_y]
                
                if plot_coordinates:
                    export_data["plot_coordinates"] = plot_coordinates
            
            # Add geographic coordinates (always include, even if zero)
            export_data["geographic_coordinates"] = {
                "start": {
                    "longitude": self.spin_start_lon.value(),
                    "latitude": self.spin_start_lat.value(),
                    "elevation": self.spin_start_elev.value()
                },
                "end": {
                    "longitude": self.spin_end_lon.value(),
                    "latitude": self.spin_end_lat.value(),
                    "elevation": self.spin_end_elev.value()
                }
            }
            
            # Write to file
            with open(filename, 'w') as f:
                json.dump(export_data, f, indent=2)
                
            QMessageBox.information(self, "Success", f"Georeference info exported to {filename}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to export georeference info: {str(e)}")

    def import_georeference_info(self):
        """Import all georeferencing information from JSON"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Import Georeference Info", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
                
            # Validate format - accept both old and new formats
            file_type = data.get("type", "")
            if file_type not in ["cross_section_georeference_info", "cross_section_reference", "cross_section_georeference"]:
                QMessageBox.warning(self, "Warning", "Invalid georeference info file format")
                return
            
            imported_items = []
            
            # Import reference points if present
            reference_points = data.get("reference_points", {})
            if reference_points:
                # Clear existing reference points
                self.clear_reference_points()
                
                # Import reference points
                for point_type, point_data in reference_points.items():
                    if point_type in ['origin', 'x_ref', 'y_ref']:
                        pixel_coords = point_data.get("pixel")
                        if pixel_coords:
                            # Store pixel coordinates
                            self.reference_points[point_type] = tuple(pixel_coords)
                            
                            # Add marker to image viewer
                            self.image_viewer.add_reference_marker(
                                pixel_coords[0], pixel_coords[1], point_type
                            )
                            
                            # Set plot coordinates in UI
                            if point_type == 'origin' and "plot" in point_data:
                                self.spin_origin_x.setValue(point_data["plot"][0])
                                self.spin_origin_y.setValue(point_data["plot"][1])
                            elif point_type == 'x_ref' and "value" in point_data:
                                self.spin_x_ref.setValue(point_data["value"])
                            elif point_type == 'y_ref' and "value" in point_data:
                                self.spin_y_ref.setValue(point_data["value"])
                
                imported_items.append("reference points")
            
            # Import plot coordinates if present
            plot_coords = data.get("plot_coordinates", {})
            if plot_coords:
                # Clear existing plot points
                self.clear_plot_georef_points()
                
                # Import plot coordinates
                for point_type, coords in plot_coords.items():
                    if point_type in ['start_plot', 'end_plot'] and len(coords) == 2:
                        if not hasattr(self, 'plot_georef_points'):
                            self.plot_georef_points = {}
                        self.plot_georef_points[point_type] = tuple(coords)
                        
                        # Add marker to image viewer  
                        self.image_viewer.add_georef_marker(coords[0], coords[1])
                        
                        # Update UI spinboxes
                        if point_type == 'start_plot':
                            self.spin_start_plot_x.setValue(coords[0])
                            self.spin_start_plot_y.setValue(coords[1])
                        elif point_type == 'end_plot':
                            self.spin_end_plot_x.setValue(coords[0])
                            self.spin_end_plot_y.setValue(coords[1])
                
                imported_items.append("plot coordinates")
            
            # Import geographic coordinates if present
            geo_coords = data.get("geographic_coordinates", {})
            if geo_coords:
                start_coords = geo_coords.get("start", {})
                if start_coords:
                    self.spin_start_lon.setValue(start_coords.get("longitude", 0))
                    self.spin_start_lat.setValue(start_coords.get("latitude", 0))
                    self.spin_start_elev.setValue(start_coords.get("elevation", 0))
                
                end_coords = geo_coords.get("end", {})
                if end_coords:
                    self.spin_end_lon.setValue(end_coords.get("longitude", 0))
                    self.spin_end_lat.setValue(end_coords.get("latitude", 0))
                    self.spin_end_elev.setValue(end_coords.get("elevation", 0))
                
                imported_items.append("geographic coordinates")
            
            if imported_items:
                items_str = ", ".join(imported_items)
                QMessageBox.information(self, "Success", f"Imported {items_str} from {filename}")
            else:
                QMessageBox.warning(self, "Warning", "No georeferencing data found in file")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to import georeference info: {str(e)}")

    def closeEvent(self, event):
        """Handle widget close event"""
        # Clear all markers when closing
        self.clear_all_markers()
        self.closingPlugin.emit()
        event.accept()


EARTH_RAD_KM = 6371.0  # Radius of the Earth in kilometers

def project_x_sec_pts_to_geog(xs, zs, start_pt, end_pt, z_unit='km', depth_pos=False):
    az = azimuth(start_pt[0],
                 start_pt[1],
                 end_pt[0],
                 end_pt[1])

    z_scale = 1000.0 if z_unit=='km' else 1.0
    if depth_pos:
        z_scale *= -1

    proj_pts = []
    for i, x in enumerate(xs):
        lon, lat = terminal_coords_from_bearing_dist(
            start_pt[0], start_pt[1], az, x)
        depth = zs[i] * z_scale
        proj_pts.append((lon, lat, depth))
    
    return proj_pts

        
def terminal_coords_from_bearing_dist(lon1: float, lat1: float, bearing, dist):
    ang_dist = dist / EARTH_RAD_KM
    lat1 = math.radians(lat1)
    lon1 = math.radians(lon1)
    bearing = math.radians(bearing)

    lat2 = math.asin(
        math.sin(lat1) * math.cos(ang_dist)
        + math.cos(lat1) * math.sin(ang_dist) * math.cos(bearing)
    )
    lon2 = lon1 + math.atan2(
        math.sin(bearing) * math.sin(ang_dist) * math.cos(lat1),
        math.cos(ang_dist) - math.sin(lat1) * math.sin(lat2),
    )

    return math.degrees(lon2), math.degrees(lat2)


def azimuth(lon_0: float, lat_0: float, lon_1, lat_1):
    r_lon_0 = math.radians(lon_0)
    r_lat_0 = math.radians(lat_0)
    r_lon_1 = math.radians(lon_1)
    r_lat_1 = math.radians(lat_1)

    dlon = r_lon_1 - r_lon_0
    y = math.sin(dlon) * math.cos(r_lat_1)

    x = math.cos(r_lat_0) * math.sin(r_lat_1) - math.sin(r_lat_0) * math.cos(
        r_lat_1
    ) * math.cos(r_lon_1 - r_lon_0)
    azimuth = math.degrees(math.atan2(y, x))

    return azimuth