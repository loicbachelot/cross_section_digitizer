# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CrossSectionDigitizerDockWidget
                                 A QGIS plugin
 digitizer and georeferencer for 1D and 2D subsurface data 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-18
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cascadia Regional Earthquake Science Center (CRESCENT)
        email                : crescentcfm@cascadiaquakes.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import csv
import math
import json

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QPointF
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox, QSplitter, QAction
from qgis.PyQt.QtGui import QPixmap, QColor
from qgis.core import (QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, 
                       QgsLineString, QgsPolygon,
                       QgsPoint, QgsField, QgsFields, QgsCoordinateReferenceSystem,
                       QgsCoordinateTransform, QgsPointXY, QgsMapLayerType)
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtCore import QVariant

# Import the new image viewer widget
from .image_viewer_widget import ImageViewerWidget


class GeographicCoordinateMapTool(QgsMapToolEmitPoint):
    """Map tool for clicking to set geographic coordinates"""
    
    def __init__(self, canvas, callback):
        super().__init__(canvas)
        self.canvas = canvas
        self.callback = callback
        
    def canvasReleaseEvent(self, e):
        """Handle map click to get coordinates"""
        try:
            # Get click point in map coordinates
            point = self.toMapCoordinates(e.pos())
            
            # Get current map CRS
            map_crs = self.canvas.mapSettings().destinationCrs()
            
            # Transform to WGS84 if needed
            wgs84_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            
            if map_crs != wgs84_crs:
                # Check if transformation is possible
                transform = QgsCoordinateTransform(map_crs, wgs84_crs, QgsProject.instance())
                if not transform.isValid():
                    self.callback(None, None, f"Cannot transform from {map_crs.authid()} to WGS84")
                    return
                
                # Transform coordinates
                try:
                    wgs84_point = transform.transform(point)
                    self.callback(wgs84_point.x(), wgs84_point.y(), None)
                except Exception as ex:
                    self.callback(None, None, f"Coordinate transformation failed: {str(ex)}")
            else:
                # Already in WGS84
                self.callback(point.x(), point.y(), None)
                
        except Exception as ex:
            self.callback(None, None, f"Error getting coordinates: {str(ex)}")


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'cross_section_digitizer_dockwidget_base.ui'))


class CrossSectionDigitizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(CrossSectionDigitizerDockWidget, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        
        # Set window flags to keep widget on top and visible
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        
        # Initialize variables
        self.image_path = None
        self.reference_points = {}  # {origin: (pixel_x, pixel_y), x_ref: (pixel_x, pixel_y), y_ref: (pixel_x, pixel_y)}
        self.plot_georef_points = {}  # {start_plot: (plot_x, plot_y), end_plot: (plot_x, plot_y)}
        self.data_series = {}  # {series_name: [(x, y), ...]}
        self.current_series = None
        self.digitizing_mode = None  # 'origin', 'x_ref', 'y_ref', 'points', 'start_plot', 'end_plot'
        
        # Map tools for geographic coordinate selection
        self.geo_map_tool = None
        self.previous_map_tool = None
        
        # Create and setup the image viewer
        self.setup_image_viewer()
        
        # Connect signals
        self.setup_connections()
        
    def setup_image_viewer(self):
        """Setup the image viewer widget"""
        # Create the image viewer
        self.image_viewer = ImageViewerWidget()
        
        # Insert the image viewer into the main layout
        # We'll add it as the first widget in the vertical layout
        main_layout = self.dockWidgetContents.layout()
        
        # Create a splitter to allow resizing between viewer and controls
        self.splitter = QSplitter(Qt.Vertical)
        
        # Make the splitter handle more visible
        self.splitter.setHandleWidth(5)
        self.update_splitter_style()
        
        # Add image viewer to splitter
        self.splitter.addWidget(self.image_viewer)
        
        # Move the tab widget to the splitter
        main_layout.removeWidget(self.tabWidget)
        self.splitter.addWidget(self.tabWidget)
        
        # Set initial sizes (80% viewer, 20% controls)
        self.splitter.setSizes([560, 140])
        
        # Don't collapse widgets when resizing
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        
        # Add splitter to main layout
        main_layout.insertWidget(0, self.splitter)
        
        # Add orientation toggle button to the image viewer toolbar
        self.add_orientation_toggle()
        
        # Connect image viewer signals
        self.image_viewer.mouseClicked.connect(self.handle_image_click)
        
    def update_splitter_style(self):
        """Update splitter style based on orientation"""
        if self.splitter.orientation() == Qt.Vertical:
            self.splitter.setStyleSheet("""
                QSplitter::handle {
                    background-color: #d0d0d0;
                    border: 1px solid #a0a0a0;
                }
                QSplitter::handle:hover {
                    background-color: #b0b0b0;
                }
                QSplitter::handle:vertical {
                    height: 5px;
                }
            """)
        else:
            self.splitter.setStyleSheet("""
                QSplitter::handle {
                    background-color: #d0d0d0;
                    border: 1px solid #a0a0a0;
                }
                QSplitter::handle:hover {
                    background-color: #b0b0b0;
                }
                QSplitter::handle:horizontal {
                    width: 5px;
                }
            """)
            
    def add_orientation_toggle(self):
        """Add button to toggle control panel orientation"""
        # Add a separator before our button
        self.image_viewer.toolbar.addSeparator()
        
        # Create orientation toggle action
        self.action_toggle_orientation = QAction("Toggle Panel Position", self)
        self.action_toggle_orientation.setToolTip("Move control panel to bottom/right")
        self.action_toggle_orientation.triggered.connect(self.toggle_orientation)
        self.image_viewer.toolbar.addAction(self.action_toggle_orientation)
        
    def toggle_orientation(self):
        """Toggle between vertical and horizontal splitter orientation"""
        # Get current sizes to maintain proportions
        sizes = self.splitter.sizes()
        total = sum(sizes)
        
        if self.splitter.orientation() == Qt.Vertical:
            # Switch to horizontal (controls on right)
            self.splitter.setOrientation(Qt.Horizontal)
            # Adjust sizes for horizontal layout - give more space to viewer
            if total > 0:
                viewer_size = int(total * 0.75)  # 75% for viewer
                control_size = total - viewer_size  # 25% for controls
                self.splitter.setSizes([viewer_size, control_size])
        else:
            # Switch to vertical (controls on bottom)
            self.splitter.setOrientation(Qt.Vertical)
            # Adjust sizes for vertical layout
            if total > 0:
                viewer_size = int(total * 0.80)  # 80% for viewer
                control_size = total - viewer_size  # 20% for controls
                self.splitter.setSizes([viewer_size, control_size])
        
        # Update splitter style for new orientation
        self.update_splitter_style()
        
        # Update button tooltip
        if self.splitter.orientation() == Qt.Vertical:
            self.action_toggle_orientation.setToolTip("Move control panel to right")
        else:
            self.action_toggle_orientation.setToolTip("Move control panel to bottom")
        
    def setup_connections(self):
        """Connect UI signals to methods"""
        # Image tab
        self.btn_load_project.clicked.connect(self.load_project)
        self.btn_export_project.clicked.connect(self.export_project)
        self.btn_clear_project.clicked.connect(self.clear_project)
        self.btn_load_image.clicked.connect(self.load_image)
        self.btn_set_origin.clicked.connect(lambda: self.start_reference_mode('origin'))
        self.btn_set_x_ref.clicked.connect(lambda: self.start_reference_mode('x_ref'))
        self.btn_set_y_ref.clicked.connect(lambda: self.start_reference_mode('y_ref'))
        self.btn_validate_reference.clicked.connect(self.validate_reference_points)
        self.btn_clear_reference.clicked.connect(self.clear_reference_points)
        self.btn_export_reference.clicked.connect(self.export_georeference_info)
        self.btn_import_reference.clicked.connect(self.import_georeference_info)
        
        # Digitize tab
        self.btn_new_series.clicked.connect(self.create_new_series)
        self.combo_series.currentTextChanged.connect(self.select_series)
        self.btn_digitize_points.clicked.connect(self.start_digitizing_points)
        self.btn_delete_point.clicked.connect(self.delete_selected_point)
        self.btn_clear_series.clicked.connect(self.clear_current_series)
        self.btn_save_series.clicked.connect(self.save_series_to_file)
        
        # Georeference tab
        self.btn_set_start_plot.clicked.connect(lambda: self.start_plot_georef_mode('start_plot'))
        self.btn_set_end_plot.clicked.connect(lambda: self.start_plot_georef_mode('end_plot'))
        self.btn_clear_plot_points.clicked.connect(self.clear_plot_georef_points)
        self.btn_create_polygon.clicked.connect(self.create_georeferenced_polygon)
        self.btn_georeference_points.clicked.connect(self.georeference_digitized_points)
        self.btn_click_start_geo.clicked.connect(self.activate_start_geo_tool)
        self.btn_click_end_geo.clicked.connect(self.activate_end_geo_tool)
        self.btn_export_georeference.clicked.connect(self.export_georeference_info)
        self.btn_import_georeference.clicked.connect(self.import_georeference_info)
        
    def load_image(self):
        """Load raster image for digitizing"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Load Image", "", 
            "Image Files (*.png *.jpg *.jpeg *.tif *.tiff *.bmp)")
        
        if file_path:
            # Load image into the viewer
            if self.image_viewer.load_image(file_path):
                self.image_path = file_path
                layer_name = os.path.basename(file_path)
                self.label_image_path.setText(f"Loaded: {layer_name}")
                
                # Clear any existing markers
                self.clear_all_markers()
            else:
                QMessageBox.warning(self, "Error", "Failed to load image")
                
    def start_reference_mode(self, mode):
        """Start reference point selection mode"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        self.digitizing_mode = mode
        # Enable digitize mode in the viewer
        self.image_viewer.action_digitize.setChecked(True)
        self.image_viewer.toggle_digitize_mode(True)
        
        mode_names = {'origin': 'origin point', 'x_ref': 'X reference point', 'y_ref': 'Y reference point'}
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", 
            f"Click on the image to set the {mode_names[mode]}", 
            level=0, duration=3)
            
    def start_plot_georef_mode(self, mode):
        """Start plot georeferencing point selection mode"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all reference points first")
            return
            
        self.digitizing_mode = mode
        # Enable digitize mode in the viewer
        self.image_viewer.action_digitize.setChecked(True)
        self.image_viewer.toggle_digitize_mode(True)
        
        mode_names = {'start_plot': 'start point', 'end_plot': 'end point'}
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", 
            f"Click on the plot to set the cross-section {mode_names[mode]}", 
            level=0, duration=3)
            
    def clear_plot_georef_points(self):
        """Clear plot georeferencing points"""
        self.plot_georef_points.clear()
        self.image_viewer.clear_georef_markers()
        self.spin_start_plot_x.setValue(0)
        self.spin_start_plot_y.setValue(0)
        self.spin_end_plot_x.setValue(0)
        self.spin_end_plot_y.setValue(0)
        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", "Plot georeferencing points cleared", level=0, duration=2)
            
    def handle_image_click(self, x, y, button):
        """Handle clicks on the image"""
        if button != Qt.LeftButton:
            return
            
        point = QPointF(x, y)
        
        if self.digitizing_mode in ['origin', 'x_ref', 'y_ref']:
            self.reference_points[self.digitizing_mode] = (x, y)
            
            # Add visual marker for reference point
            self.image_viewer.add_reference_marker(x, y, self.digitizing_mode)
            
            mode_messages = {
                'origin': f"Origin set at pixel ({x:.1f}, {y:.1f})",
                'x_ref': f"X reference set at pixel ({x:.1f}, {y:.1f})",
                'y_ref': f"Y reference set at pixel ({x:.1f}, {y:.1f})"
            }
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                mode_messages[self.digitizing_mode], 
                level=0, duration=2)
                
            # Reset digitizing mode
            self.digitizing_mode = None
            self.image_viewer.action_digitize.setChecked(False)
            self.image_viewer.toggle_digitize_mode(False)
            
        elif self.digitizing_mode in ['start_plot', 'end_plot']:
            # Convert pixel coordinates to plot coordinates
            plot_coords = self.pixel_to_plot_coords(x, y)
            if plot_coords:
                self.plot_georef_points[self.digitizing_mode] = plot_coords
                
                # Add visual marker for georeferencing point
                self.image_viewer.add_georef_marker(x, y)
                
                # Update the appropriate spinboxes
                if self.digitizing_mode == 'start_plot':
                    self.spin_start_plot_x.setValue(plot_coords[0])
                    self.spin_start_plot_y.setValue(plot_coords[1])
                    point_name = "start"
                else:  # end_plot
                    self.spin_end_plot_x.setValue(plot_coords[0])
                    self.spin_end_plot_y.setValue(plot_coords[1])
                    point_name = "end"
                    
                self.iface.messageBar().pushMessage(
                    "CrossSectionDigitizer", 
                    f"Cross-section {point_name} point set at ({plot_coords[0]:.3f}, {plot_coords[1]:.3f})", 
                    level=0, duration=2)
                    
                # Reset digitizing mode
                self.digitizing_mode = None
                self.image_viewer.action_digitize.setChecked(False)
                self.image_viewer.toggle_digitize_mode(False)
            
        elif self.digitizing_mode == 'points' and self.current_series:
            # Convert pixel coordinates to plot coordinates
            plot_coords = self.pixel_to_plot_coords(x, y)
            if plot_coords:
                self.data_series[self.current_series].append(plot_coords)
                
                # Add visual marker for data point
                self.image_viewer.add_data_marker(x, y, self.current_series, is_active=True)
                
                self.update_points_list()
                
    def pixel_to_plot_coords(self, pixel_x, pixel_y):
        """Convert pixel coordinates to plot coordinates using reference points"""
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all three reference points first")
            return None
            
        origin_px, origin_py = self.reference_points['origin']
        x_ref_px, x_ref_py = self.reference_points['x_ref']
        y_ref_px, y_ref_py = self.reference_points['y_ref']
        
        # Get reference values from spinboxes
        origin_x = self.spin_origin_x.value()
        origin_y = self.spin_origin_y.value()
        x_ref_val = self.spin_x_ref.value()
        y_ref_val = self.spin_y_ref.value()
        
        # Calculate scale factors
        x_scale = (x_ref_val - origin_x) / (x_ref_px - origin_px) if x_ref_px != origin_px else 1
        y_scale = (y_ref_val - origin_y) / (y_ref_py - origin_py) if y_ref_py != origin_py else 1
        
        # Transform pixel coordinates to plot coordinates
        plot_x = origin_x + (pixel_x - origin_px) * x_scale
        plot_y = origin_y + (pixel_y - origin_py) * y_scale
        
        return (plot_x, plot_y)
        
    def plot_to_pixel_coords(self, plot_x, plot_y):
        """Convert plot coordinates back to pixel coordinates (reverse transformation)"""
        if len(self.reference_points) < 3:
            return None
            
        origin_px, origin_py = self.reference_points['origin']
        x_ref_px, x_ref_py = self.reference_points['x_ref']
        y_ref_px, y_ref_py = self.reference_points['y_ref']
        
        # Get reference values from spinboxes
        origin_x = self.spin_origin_x.value()
        origin_y = self.spin_origin_y.value()
        x_ref_val = self.spin_x_ref.value()
        y_ref_val = self.spin_y_ref.value()
        
        # Calculate scale factors
        x_scale = (x_ref_val - origin_x) / (x_ref_px - origin_px) if x_ref_px != origin_px else 1
        y_scale = (y_ref_val - origin_y) / (y_ref_py - origin_py) if y_ref_py != origin_py else 1
        
        # Reverse transform plot coordinates to pixel coordinates
        if x_scale != 0 and y_scale != 0:
            pixel_x = origin_px + (plot_x - origin_x) / x_scale
            pixel_y = origin_py + (plot_y - origin_y) / y_scale
            return (pixel_x, pixel_y)
        return None
        
    def validate_reference_points(self):
        """Validate that all reference points and values are set"""
        missing = []

        # Check if image is loaded
        if not self.image_path:
            missing.append("- No image loaded")

        # Check reference points
        if 'origin' not in self.reference_points:
            missing.append("- Origin point not set (click 'Set Origin' button)")
        else:
            # Check origin values
            if self.spin_origin_x.value() == 0 and self.spin_origin_y.value() == 0:
                missing.append("- Origin X,Y values not set (enter values in spinboxes)")

        if 'x_ref' not in self.reference_points:
            missing.append("- X reference point not set (click 'Set X Reference Point' button)")
        else:
            # Check X reference value
            if self.spin_x_ref.value() == 0:
                missing.append("- X reference value not set (enter value in spinbox)")

        if 'y_ref' not in self.reference_points:
            missing.append("- Y reference point not set (click 'Set Y Reference Point' button)")
        else:
            # Check Y reference value  
            if self.spin_y_ref.value() == 0:
                missing.append("- Y reference value not set (enter value in spinbox)")

        # Show results
        if missing:
            msg = "Reference points validation failed. Missing:\n\n" + "\n".join(missing)
            QMessageBox.warning(self, "Validation Failed", msg)
        else:
            # Additional validation - check if points are not collinear
            if len(self.reference_points) == 3:
                origin = self.reference_points['origin']
                x_ref = self.reference_points['x_ref']
                y_ref = self.reference_points['y_ref']

                # Check if points form a valid coordinate system
                # Calculate vectors
                vx = (x_ref[0] - origin[0], x_ref[1] - origin[1])
                vy = (y_ref[0] - origin[0], y_ref[1] - origin[1])

                # Check if vectors are too parallel (cross product close to zero)
                cross = abs(vx[0] * vy[1] - vx[1] * vy[0])
                if cross < 10:  # threshold in pixels
                    QMessageBox.warning(self, "Validation Warning", 
                        "Reference points appear to be nearly collinear.\n"
                        "This may result in poor coordinate transformation.\n"
                        "Consider repositioning the reference points.")
                else:
                    # Validation successful - enable coordinate transformation
                    self.image_viewer.set_coordinate_transform_callback(self.pixel_to_plot_coords)
                    QMessageBox.information(self, "Validation Successful", 
                        "All reference points and values are properly set!\n"
                        "You can now proceed to digitize points.\n"
                        "Plot coordinates will now be displayed in the status bar.")

    def clear_reference_points(self):
        """Clear all reference points"""
        self.reference_points.clear()
        self.image_viewer.clear_reference_markers()

        # Disable coordinate transformation
        self.image_viewer.set_coordinate_transform_callback(None)

        # Reset spinbox values to 0
        self.spin_origin_x.setValue(0)
        self.spin_origin_y.setValue(0)
        self.spin_x_ref.setValue(0)
        self.spin_y_ref.setValue(0)

        self.iface.messageBar().pushMessage(
            "CrossSectionDigitizer", "Reference points cleared", level=0, duration=2)
            
    def create_new_series(self):
        """Create a new data series"""
        series_name = self.line_series_name.text().strip()
        if not series_name:
            QMessageBox.warning(self, "Error", "Please enter a series name")
            return
            
        if series_name in self.data_series:
            QMessageBox.warning(self, "Error", "Series name already exists")
            return
            
        self.data_series[series_name] = []
        self.combo_series.addItem(series_name)
        self.combo_series.setCurrentText(series_name)
        self.current_series = series_name
        self.line_series_name.clear()
        
    def select_series(self, series_name):
        """Select current data series"""
        if series_name in self.data_series:
            self.current_series = series_name
            # Update marker colors based on active series
            self.image_viewer.update_series_colors(series_name)
            self.update_points_list()
            
    def start_digitizing_points(self):
        """Start digitizing points mode"""
        if not self.current_series:
            QMessageBox.warning(self, "Error", "Please create or select a data series first")
            return
            
        if len(self.reference_points) < 3:
            QMessageBox.warning(self, "Error", "Please set all reference points first")
            return
        
        # Toggle digitizing mode based on button state
        if self.btn_digitize_points.isChecked():
            self.digitizing_mode = 'points'
            # Enable digitize mode in the viewer
            self.image_viewer.action_digitize.setChecked(True)
            self.image_viewer.toggle_digitize_mode(True)
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                "Click on points to digitize. Click 'Start Digitizing Points' again to stop.", 
                level=0, duration=5)
        else:
            # Stop digitizing
            self.digitizing_mode = None
            self.image_viewer.action_digitize.setChecked(False)
            self.image_viewer.toggle_digitize_mode(False)
            
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                "Digitizing stopped.", 
                level=0, duration=2)
            
    def update_points_list(self):
        """Update the points list widget"""
        self.list_points.clear()
        if self.current_series and self.current_series in self.data_series:
            for i, (x, y) in enumerate(self.data_series[self.current_series]):
                self.list_points.addItem(f"Point {i+1}: ({x:.3f}, {y:.3f})")
                
    def delete_selected_point(self):
        """Delete selected point from current series"""
        if not self.current_series or self.current_series not in self.data_series:
            return
            
        current_row = self.list_points.currentRow()
        if current_row >= 0:
            del self.data_series[self.current_series][current_row]
            
            # Clear and recreate markers for this series
            self.image_viewer.clear_series_markers(self.current_series)
            self.recreate_series_markers(self.current_series)
            
            self.update_points_list()
            
    def recreate_series_markers(self, series_name):
        """Recreate visual markers for a data series"""
        if series_name not in self.data_series:
            return
            
        is_active = (series_name == self.current_series)
        
        for plot_x, plot_y in self.data_series[series_name]:
            # Convert plot coordinates back to pixel coordinates for marker placement
            pixel_coords = self.plot_to_pixel_coords(plot_x, plot_y)
            if pixel_coords:
                self.image_viewer.add_data_marker(pixel_coords[0], pixel_coords[1], 
                                                 series_name, is_active)
            
    def save_series_to_file(self):
        """Save current series to CSV file"""
        if not self.current_series or not self.data_series[self.current_series]:
            QMessageBox.warning(self, "Error", "No data to save")
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Series", f"{self.current_series}.csv", "CSV Files (*.csv)")
            
        if file_path:
            with open(file_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['X', 'Y'])
                for x, y in self.data_series[self.current_series]:
                    writer.writerow([x, y])
            QMessageBox.information(self, "Success", f"Series saved to {file_path}")
            
    def clear_current_series(self):
        """Remove the current series (removes series and all its points from dropdown)"""
        if not self.current_series:
            QMessageBox.warning(self, "Warning", "No series selected")
            return
            
        if self.current_series not in self.data_series:
            QMessageBox.warning(self, "Warning", "Selected series not found")
            return
            
        # Ask for confirmation
        reply = QMessageBox.question(
            self, "Remove Series", 
            f"Are you sure you want to remove series '{self.current_series}'?\n\nThis will remove the series from the dropdown.\nThis action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            series_to_clear = self.current_series
            
            # Clear visual markers for this series
            self.image_viewer.clear_series_markers(series_to_clear)
            
            # Remove from data structure
            del self.data_series[series_to_clear]
            
            # Remove from combo box
            index = self.combo_series.findText(series_to_clear)
            if index >= 0:
                self.combo_series.removeItem(index)
            
            # Update current series selection
            if self.combo_series.count() > 0:
                # Select the first available series
                self.current_series = self.combo_series.itemText(0)
                self.combo_series.setCurrentIndex(0)
            else:
                # No series left
                self.current_series = None
                
            # Update the points list display
            self.update_points_list()
            
            QMessageBox.information(self, "Success", f"Series '{series_to_clear}' removed successfully")
            
    def create_georeferenced_polygon(self):
        """Create georeferenced polygon representing the cross-section"""
        if not self.image_path:
            QMessageBox.warning(self, "Error", "Please load an image first")
            return
            
        # Check if plot coordinates are set
        if 'start_plot' not in self.plot_georef_points or 'end_plot' not in self.plot_georef_points:
            QMessageBox.warning(self, "Error", "Please set start and end points on the plot first")
            return
            
        # Get georeferencing points
        start_lon = self.spin_start_lon.value()
        start_lat = self.spin_start_lat.value()
        start_elev = self.spin_start_elev.value()
        end_lon = self.spin_end_lon.value()
        end_lat = self.spin_end_lat.value()
        end_elev = self.spin_end_elev.value()
        
        if start_lon == 0 and start_lat == 0 and end_lon == 0 and end_lat == 0:
            QMessageBox.warning(self, "Error", "Please set georeferencing coordinates")
            return
            
        # Image plot coordinates
        #   pixel coordinates
        nx, nz = self.image_viewer.get_image_size()
        ul = (0,0)
        ur = (nx,0)
        ll = (0,nz)
        lr = (nx,nz)
        #   x-sec coordinates
        ul_xc = self.pixel_to_plot_coords(*ul)
        ur_xc = self.pixel_to_plot_coords(*ur)
        ll_xc = self.pixel_to_plot_coords(*ll)
        lr_xc = self.pixel_to_plot_coords(*lr)
        #   geog coordinates
        geog_coords = project_x_sec_pts_to_geog(
            (ul_xc[0], ur_xc[0], ll_xc[0], lr_xc[0]),
            (ul_xc[1], ur_xc[1], ll_xc[1], lr_xc[1]),
            (start_lon, start_lat, start_elev),
            (end_lon, end_lat, end_elev),
            z_unit="km",
            depth_pos=False
        )

        ul_geog, ur_geog, ll_geog, lr_geog = geog_coords
        
        # Create polygon layer
        layer = QgsVectorLayer("PolygonZ?crs=EPSG:4326", "Cross_Section_Polygon", "memory")
        provider = layer.dataProvider()
        
        # Add fields
        fields = QgsFields()
        fields.append(QgsField("name", QVariant.String))
        fields.append(QgsField("image_path", QVariant.String))
        provider.addAttributes(fields)
        layer.updateFields()
        
        
        # Create rectangle points
        rect_points = [
            QgsPoint(x=ul_geog[0], y=ul_geog[1], z=ul_geog[2]),
            QgsPoint(x=ur_geog[0], y=ur_geog[1], z=ur_geog[2]),
            QgsPoint(x=lr_geog[0], y=lr_geog[1], z=lr_geog[2]),
            QgsPoint(x=ll_geog[0], y=ll_geog[1], z=ll_geog[2]),
            QgsPoint(x=ul_geog[0], y=ul_geog[1], z=ul_geog[2]),
        ]

        # create point layer for debugging
        #pt_layer = QgsVectorLayer("PointZ?crs=EPSG:4326", "Image Corners", "memory")
        #pt_provider = pt_layer.dataProvider()
        #pt_fields = QgsFields()
        #pt_fields.append(QgsField("position", QVariant.String))
        #pt_provider.addAttributes(pt_fields)
        #pt_layer.updateFields()

        #field_names = ["ul", "ur", "lr", "ll"]
        #for i, pt in enumerate(rect_points[:4]):
        #    pt_ft = QgsFeature()
        #    pt_ft.setGeometry(QgsGeometry.fromPoint(pt))
        #    pt_ft.setAttributes(["position", field_names[i]])
        #    pt_provider.addFeatures([pt_ft])
        #    pt_layer.updateExtents()
        #    QMessageBox.information(self, "Success", f"{field_names[i]}, {pt_ft.geometry().asWkt()}")

        #QgsProject.instance().addMapLayer(pt_layer)
        
        
        # Create feature
        ring   = QgsLineString(rect_points)      # outer ring
        poly3d = QgsPolygon(ring)                # no interior rings for a rectangle
        geom   = QgsGeometry(poly3d)    

        feature = QgsFeature()
        feature.setGeometry(geom)
        feature.setAttributes([
            "Cross_Section", self.image_path,
        ])
        
        provider.addFeatures([feature])
        layer.updateExtents()
        
        # Add to project
        QgsProject.instance().addMapLayer(layer)
        QMessageBox.information(self, "Success", "Georeferenced polygon created")

        
        
    def georeference_digitized_points(self):
        """Georeference all digitized data series"""
        if not self.data_series:
            QMessageBox.warning(self, "Error", "No digitized data available")
            return
            
        # Check if plot coordinates are set
        if 'start_plot' not in self.plot_georef_points or 'end_plot' not in self.plot_georef_points:
            QMessageBox.warning(self, "Error", "Please set start and end points on the plot first")
            return
            
        # Get georeferencing parameters
        start_lon = self.spin_start_lon.value()
        start_lat = self.spin_start_lat.value()
        start_elev = self.spin_start_elev.value()
        end_lon = self.spin_end_lon.value()
        end_lat = self.spin_end_lat.value()
        end_elev = self.spin_end_elev.value()
        
        if start_lon == 0 and start_lat == 0 and end_lon == 0 and end_lat == 0:
            QMessageBox.warning(self, "Error", "Please set georeferencing coordinates")
            return
            
        # Track updated/created layers
        updated_layers = []
        created_layers = []
        
        # Create or update point layer for each series
        for series_name, points in self.data_series.items():
            if not points:
                continue
                
            layer_name = f"Georeferenced_{series_name}"
            
            # Check if layer already exists in the project
            existing_layer = None
            for layer in QgsProject.instance().mapLayers().values():
                if layer.name() == layer_name and layer.type() == QgsMapLayerType.VectorLayer:
                    existing_layer = layer
                    break
            
            # Use existing layer or create new one
            if existing_layer:
                layer = existing_layer
                # Clear existing features
                provider = layer.dataProvider()
                provider.deleteFeatures(provider.getFeatureIds())
                updated_layers.append(series_name)
            else:
                # Create new layer
                layer = QgsVectorLayer("PointZ?crs=EPSG:4326", layer_name, "memory")
                provider = layer.dataProvider()
                
                # Add fields for new layers
                fields = QgsFields()
                fields.append(QgsField("series", QVariant.String))
                fields.append(QgsField("point_id", QVariant.Int))
                provider.addAttributes(fields)
                layer.updateFields()
                created_layers.append(series_name)
            
            # Generate features
            features = []
            for i, (plot_x, plot_y) in enumerate(points):
                georef_points = project_x_sec_pts_to_geog(
                    [plot_x], [plot_y],
                    (start_lon, start_lat, start_elev),
                    (end_lon, end_lat, end_elev),
                    z_unit="km",
                    depth_pos=False
                )
                
                if georef_points:
                    lon, lat, elev = georef_points[0]
                    
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPoint(QgsPoint(lon, lat, elev)))
                    feature.setAttributes([
                        series_name, i+1
                    ])
                    features.append(feature)
            
            # Add features to layer
            if features:
                provider.addFeatures(features)
                layer.updateExtents()
                
                # Add to project only if it's a new layer
                if layer not in QgsProject.instance().mapLayers().values():
                    QgsProject.instance().addMapLayer(layer)
        
        # Show appropriate success message
        if updated_layers and created_layers:
            message = f"Updated layers: {', '.join(updated_layers)}\nCreated layers: {', '.join(created_layers)}"
        elif updated_layers:
            message = f"Updated existing layers: {', '.join(updated_layers)}"
        elif created_layers:
            message = f"Created new layers: {', '.join(created_layers)}"
        else:
            message = "No layers were created or updated"
        
        QMessageBox.information(self, "Success", f"Digitized points georeferenced!\n\n{message}")

    def clear_all_markers(self):
        """Clear all markers from the image viewer"""
        self.image_viewer.clear_reference_markers()
        self.image_viewer.clear_series_markers()
        self.image_viewer.clear_georef_markers()

    def export_georeference_info(self):
        """Export all georeferencing information to JSON"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Georeference Info", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        # Add .json extension if not present
        if not filename.lower().endswith('.json'):
            filename += '.json'
            
        try:
            # Build export data with combined format
            export_data = {
                "type": "cross_section_georeference_info",
                "version": "1.0",
                "image_path": getattr(self, 'image_path', ""),
                "reference_points": None,
                "plot_coordinates": None,
                "geographic_coordinates": None
            }
            
            # Add reference points if they exist
            if hasattr(self, 'reference_points') and self.reference_points:
                reference_points = {}
                for point_type, (pixel_x, pixel_y) in self.reference_points.items():
                    point_data = {
                        "pixel": [pixel_x, pixel_y]
                    }
                    
                    # Add plot coordinates based on point type
                    if point_type == 'origin':
                        point_data["plot"] = [
                            self.spin_origin_x.value(),
                            self.spin_origin_y.value()
                        ]
                    elif point_type == 'x_ref':
                        point_data["value"] = self.spin_x_ref.value()
                    elif point_type == 'y_ref':
                        point_data["value"] = self.spin_y_ref.value()
                        
                    reference_points[point_type] = point_data
                
                if reference_points:
                    export_data["reference_points"] = reference_points
            
            # Add plot coordinates if they exist
            if hasattr(self, 'plot_georef_points') and self.plot_georef_points:
                plot_coordinates = {}
                for point_type, (plot_x, plot_y) in self.plot_georef_points.items():
                    plot_coordinates[point_type] = [plot_x, plot_y]
                
                if plot_coordinates:
                    export_data["plot_coordinates"] = plot_coordinates
            
            # Add geographic coordinates (always include, even if zero)
            export_data["geographic_coordinates"] = {
                "start": {
                    "longitude": self.spin_start_lon.value(),
                    "latitude": self.spin_start_lat.value(),
                    "elevation": self.spin_start_elev.value()
                },
                "end": {
                    "longitude": self.spin_end_lon.value(),
                    "latitude": self.spin_end_lat.value(),
                    "elevation": self.spin_end_elev.value()
                }
            }
            
            # Write to file
            with open(filename, 'w') as f:
                json.dump(export_data, f, indent=2)
                
            QMessageBox.information(self, "Success", f"Georeference info exported to {filename}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to export georeference info: {str(e)}")

    def import_georeference_info(self):
        """Import all georeferencing information from JSON"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Import Georeference Info", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
                
            # Validate format - accept both old and new formats
            file_type = data.get("type", "")
            if file_type not in ["cross_section_georeference_info", "cross_section_reference", "cross_section_georeference"]:
                QMessageBox.warning(self, "Warning", "Invalid georeference info file format")
                return
            
            imported_items = []
            
            # Import reference points if present
            if self._load_reference_points_from_data(data):
                imported_items.append("reference points")
            
            # Import plot coordinates if present
            if self._load_plot_coordinates_from_data(data):
                imported_items.append("plot coordinates")
            
            # Import geographic coordinates if present
            if self._load_geographic_coordinates_from_data(data):
                imported_items.append("geographic coordinates")
            
            if imported_items:
                items_str = ", ".join(imported_items)
                QMessageBox.information(self, "Success", f"Imported {items_str} from {filename}")
            else:
                QMessageBox.warning(self, "Warning", "No georeferencing data found in file")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to import georeference info: {str(e)}")

    def _load_reference_points_from_data(self, data):
        """Helper function to load reference points from JSON data"""
        reference_points = data.get("reference_points", {})
        if not reference_points:
            return False
            
        # Clear existing reference points
        self.clear_reference_points()
        
        # Import reference points
        for point_type, point_data in reference_points.items():
            if point_type in ['origin', 'x_ref', 'y_ref']:
                pixel_coords = point_data.get("pixel")
                if pixel_coords:
                    # Store pixel coordinates
                    self.reference_points[point_type] = tuple(pixel_coords)
                    
                    # Add marker to image viewer
                    self.image_viewer.add_reference_marker(
                        pixel_coords[0], pixel_coords[1], point_type
                    )
                    
                    # Set plot coordinates in UI
                    if point_type == 'origin' and "plot" in point_data:
                        self.spin_origin_x.setValue(point_data["plot"][0])
                        self.spin_origin_y.setValue(point_data["plot"][1])
                    elif point_type == 'x_ref' and "value" in point_data:
                        self.spin_x_ref.setValue(point_data["value"])
                    elif point_type == 'y_ref' and "value" in point_data:
                        self.spin_y_ref.setValue(point_data["value"])
        
        return True

    def _load_plot_coordinates_from_data(self, data):
        """Helper function to load plot coordinates from JSON data"""
        plot_coords = data.get("plot_coordinates", {})
        if not plot_coords:
            return False
            
        # Clear existing plot points
        self.clear_plot_georef_points()
        
        # Import plot coordinates
        for point_type, coords in plot_coords.items():
            if point_type in ['start_plot', 'end_plot'] and len(coords) == 2:
                if not hasattr(self, 'plot_georef_points'):
                    self.plot_georef_points = {}
                self.plot_georef_points[point_type] = tuple(coords)
                
                # Add visual marker - convert plot coordinates to pixel coordinates
                pixel_coords = self.plot_to_pixel_coords(coords[0], coords[1])
                if pixel_coords:
                    pixel_x, pixel_y = pixel_coords
                    self.image_viewer.add_georef_marker(pixel_x, pixel_y)
                
                # Update UI spinboxes
                if point_type == 'start_plot':
                    self.spin_start_plot_x.setValue(coords[0])
                    self.spin_start_plot_y.setValue(coords[1])
                elif point_type == 'end_plot':
                    self.spin_end_plot_x.setValue(coords[0])
                    self.spin_end_plot_y.setValue(coords[1])
        
        return True

    def _load_geographic_coordinates_from_data(self, data):
        """Helper function to load geographic coordinates from JSON data"""
        geo_coords = data.get("geographic_coordinates", {})
        if not geo_coords:
            return False
            
        start_coords = geo_coords.get("start", {})
        if start_coords:
            self.spin_start_lon.setValue(start_coords.get("longitude", 0))
            self.spin_start_lat.setValue(start_coords.get("latitude", 0))
            self.spin_start_elev.setValue(start_coords.get("elevation", 0))
        
        end_coords = geo_coords.get("end", {})
        if end_coords:
            self.spin_end_lon.setValue(end_coords.get("longitude", 0))
            self.spin_end_lat.setValue(end_coords.get("latitude", 0))
            self.spin_end_elev.setValue(end_coords.get("elevation", 0))
        
        return True

    def activate_start_geo_tool(self):
        """Activate map tool to click for start point geographic coordinates"""
        self._activate_geo_coordinate_tool('start')
    
    def activate_end_geo_tool(self):
        """Activate map tool to click for end point geographic coordinates"""
        self._activate_geo_coordinate_tool('end')
    
    def _activate_geo_coordinate_tool(self, point_type):
        """Helper method to activate geographic coordinate selection tool"""
        try:
            # Check if we have access to the map canvas
            if not self.iface or not self.iface.mapCanvas():
                QMessageBox.warning(self, "Warning", "Cannot access QGIS map canvas")
                return
            
            canvas = self.iface.mapCanvas()
            
            # Check map CRS and warn if not WGS84
            map_crs = canvas.mapSettings().destinationCrs()
            wgs84_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            
            if map_crs != wgs84_crs:
                # Check if transformation is possible
                transform = QgsCoordinateTransform(map_crs, wgs84_crs, QgsProject.instance())
                if not transform.isValid():
                    QMessageBox.warning(
                        self, "CRS Warning", 
                        f"Cannot transform coordinates from {map_crs.authid()} to WGS84.\n\n"
                        "Please set your QGIS project to use WGS84 (EPSG:4326) coordinate system "
                        "for accurate geographic coordinate selection."
                    )
                    return
                else:
                    # Transformation is possible, but warn user
                    reply = QMessageBox.question(
                        self, "CRS Notice",
                        f"Map is using {map_crs.authid()}, not WGS84.\n\n"
                        "Coordinates will be automatically transformed to WGS84 lat/lon.\n\n"
                        "Continue with map clicking?",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.Yes
                    )
                    if reply != QMessageBox.Yes:
                        return
            
            # Store previous map tool to restore later
            self.previous_map_tool = canvas.mapTool()
            
            # Create callback function for this specific point type
            def coordinate_callback(lon, lat, error):
                self._handle_geo_coordinate_result(point_type, lon, lat, error)
            
            # Create and activate the map tool
            self.geo_map_tool = GeographicCoordinateMapTool(canvas, coordinate_callback)
            canvas.setMapTool(self.geo_map_tool)
            
            # Update button text to indicate active mode
            if point_type == 'start':
                self.btn_click_start_geo.setText("Click on Map (Active)")
                self.btn_click_start_geo.setEnabled(False)
            else:
                self.btn_click_end_geo.setText("Click on Map (Active)")
                self.btn_click_end_geo.setEnabled(False)
            
            # Show message to user
            self.iface.messageBar().pushMessage(
                "Cross Section Digitizer", 
                f"Click on the map to set {point_type} point geographic coordinates. Press Escape to cancel.",
                level=0,  # Info level
                duration=5
            )
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to activate map tool: {str(e)}")
    
    def _handle_geo_coordinate_result(self, point_type, lon, lat, error):
        """Handle the result from map coordinate selection"""
        try:
            # Restore previous map tool
            if self.previous_map_tool and self.iface.mapCanvas():
                self.iface.mapCanvas().setMapTool(self.previous_map_tool)
            
            # Reset button states
            self.btn_click_start_geo.setText("Click on Map for Start Point")
            self.btn_click_start_geo.setEnabled(True)
            self.btn_click_end_geo.setText("Click on Map for End Point")
            self.btn_click_end_geo.setEnabled(True)
            
            if error:
                QMessageBox.warning(self, "Coordinate Selection Error", error)
                return
            
            if lon is None or lat is None:
                QMessageBox.warning(self, "Warning", "No coordinates received from map click")
                return
            
            # Set the coordinates in the appropriate spinboxes
            if point_type == 'start':
                self.spin_start_lon.setValue(lon)
                self.spin_start_lat.setValue(lat)
                self.iface.messageBar().pushMessage(
                    "Cross Section Digitizer",
                    f"Start point set to: {lon:.6f}, {lat:.6f}",
                    level=3,  # Success level
                    duration=3
                )
            else:  # end
                self.spin_end_lon.setValue(lon)
                self.spin_end_lat.setValue(lat)
                self.iface.messageBar().pushMessage(
                    "Cross Section Digitizer",
                    f"End point set to: {lon:.6f}, {lat:.6f}",
                    level=3,  # Success level
                    duration=3
                )
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to handle coordinate result: {str(e)}")

    def export_project(self):
        """Export complete project data to JSON"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Project", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        # Add .json extension if not present
        if not filename.lower().endswith('.json'):
            filename += '.json'
            
        try:
            from datetime import datetime
            
            # Build project data focused on essential data
            project_data = {
                "type": "cross_section_project",
                "version": "1.0",
                "created": datetime.now().isoformat(),
                "image": None,
                "coordinate_system": None,
                "georeferencing": None,
                "data_series": None
            }
            
            # Add image information
            if hasattr(self, 'image_path') and self.image_path:
                image_size = self.image_viewer.get_image_size()
                project_data["image"] = {
                    "path": self.image_path,
                    "width": image_size[0] if image_size else None,
                    "height": image_size[1] if image_size else None
                }
            
            # Add coordinate system (reference points)
            if hasattr(self, 'reference_points') and self.reference_points:
                reference_data = {}
                for point_type, (pixel_x, pixel_y) in self.reference_points.items():
                    point_data = {"pixel": [pixel_x, pixel_y]}
                    
                    if point_type == 'origin':
                        point_data["plot"] = [
                            self.spin_origin_x.value(),
                            self.spin_origin_y.value()
                        ]
                    elif point_type == 'x_ref':
                        point_data["value"] = self.spin_x_ref.value()
                    elif point_type == 'y_ref':
                        point_data["value"] = self.spin_y_ref.value()
                        
                    reference_data[point_type] = point_data
                
                if reference_data:
                    project_data["coordinate_system"] = {
                        "reference_points": reference_data,
                        "is_validated": len(reference_data) == 3
                    }
            
            # Add georeferencing information
            geo_data = {}
            
            # Plot coordinates
            if hasattr(self, 'plot_georef_points') and self.plot_georef_points:
                plot_coords = {}
                for point_type, (plot_x, plot_y) in self.plot_georef_points.items():
                    plot_coords[point_type] = [plot_x, plot_y]
                geo_data["plot_coordinates"] = plot_coords
            
            # Geographic coordinates
            geo_data["geographic_coordinates"] = {
                "start": {
                    "longitude": self.spin_start_lon.value(),
                    "latitude": self.spin_start_lat.value(),
                    "elevation": self.spin_start_elev.value()
                },
                "end": {
                    "longitude": self.spin_end_lon.value(),
                    "latitude": self.spin_end_lat.value(),
                    "elevation": self.spin_end_elev.value()
                }
            }
            
            if geo_data:
                project_data["georeferencing"] = geo_data
            
            # Add data series
            if hasattr(self, 'data_series') and self.data_series:
                series_data = {
                    "active_series": getattr(self, 'current_series', None),
                    "series": dict(self.data_series)  # Copy the series data
                }
                project_data["data_series"] = series_data
            
            # Write to file
            with open(filename, 'w') as f:
                json.dump(project_data, f, indent=2)
                
            QMessageBox.information(self, "Success", f"Project exported to {filename}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to export project: {str(e)}")

    def load_project(self):
        """Load complete project data from JSON"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Load Project", "", "JSON Files (*.json);;All Files (*)"
        )
        if not filename:
            return
            
        try:
            with open(filename, 'r') as f:
                project_data = json.load(f)
            
            # Validate basic project structure
            project_type = project_data.get("type", "")
            if project_type == "cross_section_project":
                # New simplified project format
                pass
            elif project_type in ["cross_section_georeference_info", "cross_section_reference", "cross_section_georeference"]:
                # Legacy georeference file
                self.import_georeference_info()
                return
            else:
                QMessageBox.warning(self, "Warning", "Invalid project file format")
                return
            
            loaded_items = []
            
            # Clear existing data
            reply = QMessageBox.question(
                self, "Load Project", 
                "Loading a project will replace all current data.\n\nDo you want to continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # Load image
            image_info = project_data.get("image")
            if image_info and image_info.get("path"):
                image_path = image_info["path"]
                if os.path.exists(image_path):
                    self.load_image_file(image_path)
                    loaded_items.append("image")
                else:
                    QMessageBox.warning(self, "Missing File", f"Image file not found: {image_path}")
            
            # Load coordinate system (reference points)
            coord_system = project_data.get("coordinate_system")
            if coord_system and coord_system.get("reference_points"):
                # Adapt project data structure to match helper function expectations
                adapted_data = {"reference_points": coord_system["reference_points"]}
                if self._load_reference_points_from_data(adapted_data):
                    loaded_items.append("coordinate system")
            
            # Load georeferencing
            georef = project_data.get("georeferencing")
            if georef:
                georef_loaded = False
                
                # Load plot coordinates using helper function
                if self._load_plot_coordinates_from_data(georef):
                    georef_loaded = True
                
                # Load geographic coordinates using helper function
                if self._load_geographic_coordinates_from_data(georef):
                    georef_loaded = True
                
                if georef_loaded:
                    loaded_items.append("georeferencing")
            
            # Load data series
            data_series_info = project_data.get("data_series")
            if data_series_info and data_series_info.get("series"):
                # Clear existing series
                if hasattr(self, 'data_series'):
                    self.data_series.clear()
                    self.combo_series.clear()
                else:
                    self.data_series = {}
                
                # Load series data
                for series_name, points in data_series_info["series"].items():
                    self.data_series[series_name] = points
                    self.combo_series.addItem(series_name)
                    
                    # Add visual markers - convert plot coordinates back to pixel coordinates
                    for plot_x, plot_y in points:
                        pixel_coords = self.plot_to_pixel_coords(plot_x, plot_y)
                        if pixel_coords:
                            pixel_x, pixel_y = pixel_coords
                            self.image_viewer.add_data_marker(pixel_x, pixel_y, series_name, False)
                
                # Set active series
                active_series = data_series_info.get("active_series")
                if active_series and active_series in self.data_series:
                    self.current_series = active_series
                    index = self.combo_series.findText(active_series)
                    if index >= 0:
                        self.combo_series.setCurrentIndex(index)
                        # Update marker colors
                        self.image_viewer.update_series_colors(active_series)
                elif self.data_series:
                    # Set first series as active
                    first_series = next(iter(self.data_series))
                    self.current_series = first_series
                    self.combo_series.setCurrentIndex(0)
                    self.image_viewer.update_series_colors(first_series)
                
                # Update points list
                self.update_points_list()
                loaded_items.append("data series")
            
            # Validate coordinate system if reference points were loaded
            validation_message = ""
            if "coordinate system" in loaded_items:
                # Check if validation would pass (simple check without dialogs)
                missing = []
                if not self.image_path:
                    missing.append("- No image loaded")
                if 'origin' not in self.reference_points:
                    missing.append("- Origin point not set")
                elif self.spin_origin_x.value() == 0 and self.spin_origin_y.value() == 0:
                    missing.append("- Origin X,Y values not set")
                if 'x_ref' not in self.reference_points:
                    missing.append("- X reference point not set")
                elif self.spin_x_ref.value() == 0:
                    missing.append("- X reference value not set")
                if 'y_ref' not in self.reference_points:
                    missing.append("- Y reference point not set")
                elif self.spin_y_ref.value() == 0:
                    missing.append("- Y reference value not set")
                
                if missing:
                    validation_message = f"\n\nCoordinate System Warning:\nReference points incomplete:\n" + "\n".join(missing)
                elif len(self.reference_points) == 3:
                    # Check collinearity
                    origin = self.reference_points['origin']
                    x_ref = self.reference_points['x_ref']
                    y_ref = self.reference_points['y_ref']
                    vx = (x_ref[0] - origin[0], x_ref[1] - origin[1])
                    vy = (y_ref[0] - origin[0], y_ref[1] - origin[1])
                    cross = abs(vx[0] * vy[1] - vx[1] * vy[0])
                    if cross < 10:
                        validation_message = f"\n\nCoordinate System Warning:\nReference points are nearly collinear.\nThis may result in poor coordinate transformation."
                    else:
                        # Valid - enable coordinate transformation
                        self.image_viewer.set_coordinate_transform_callback(self.pixel_to_plot_coords)
            
            if loaded_items:
                items_str = ", ".join(loaded_items)
                QMessageBox.information(self, "Success", f"Project loaded successfully!\n\nLoaded: {items_str}{validation_message}")
            else:
                QMessageBox.warning(self, "Warning", "No data found in project file")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load project: {str(e)}")

    def clear_project(self):
        """Clear all project data with confirmation dialog"""
        # Show confirmation dialog
        reply = QMessageBox.question(
            self, "Clear Project", 
            "This will clear all project data including:\n\n"
            " Loaded image\n"
            " Reference points and coordinate system\n"
            " All digitized data series\n"
            " Georeferencing information\n\n"
            "Are you sure you want to continue?\n\n"
            "This action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No  # Default to No for safety
        )
        
        if reply != QMessageBox.Yes:
            return
        
        try:
            # Clear image
            self.image_path = None
            self.label_image_path.setText("No image loaded")
            
            # Clear image viewer
            if hasattr(self, 'image_viewer'):
                # Clear the scene - this will automatically remove all graphics items
                if hasattr(self.image_viewer, 'scene') and self.image_viewer.scene:
                    self.image_viewer.scene.clear()
                
                # Reset internal marker tracking without trying to remove items from scene
                if hasattr(self.image_viewer, 'reference_markers'):
                    self.image_viewer.reference_markers.clear()
                if hasattr(self.image_viewer, 'series_markers'):
                    self.image_viewer.series_markers.clear()
                if hasattr(self.image_viewer, 'georef_markers'):
                    self.image_viewer.georef_markers.clear()
                    
                # Reset image state
                self.image_viewer.image_item = None
                self.image_viewer.image_pixmap = None
                
            # Clear reference points
            if hasattr(self, 'reference_points'):
                self.reference_points.clear()
            
            # Disable coordinate transformation callback
            if hasattr(self, 'image_viewer'):
                self.image_viewer.set_coordinate_transform_callback(None)
            
            # Reset reference point UI values
            self.spin_origin_x.setValue(0.0)
            self.spin_origin_y.setValue(0.0)
            self.spin_x_ref.setValue(0.0)
            self.spin_y_ref.setValue(0.0)
            
            # Clear plot georeferencing points
            if hasattr(self, 'plot_georef_points'):
                self.plot_georef_points.clear()
                
            # Reset plot coordinate UI values
            self.spin_start_plot_x.setValue(0.0)
            self.spin_start_plot_y.setValue(0.0)
            self.spin_end_plot_x.setValue(0.0)
            self.spin_end_plot_y.setValue(0.0)
            
            # Reset geographic coordinates
            self.spin_start_lon.setValue(0.0)
            self.spin_start_lat.setValue(0.0)
            self.spin_start_elev.setValue(0.0)
            self.spin_end_lon.setValue(0.0)
            self.spin_end_lat.setValue(0.0)
            self.spin_end_elev.setValue(0.0)
            
            # Clear data series
            if hasattr(self, 'data_series'):
                self.data_series.clear()
            self.current_series = None
            self.combo_series.clear()
            self.list_points.clear()
            
            # Reset digitizing mode
            self.digitizing_mode = None
            if hasattr(self, 'image_viewer'):
                self.image_viewer.action_digitize.setChecked(False)
                self.image_viewer.toggle_digitize_mode(False)
            
            # Disable digitize points button
            self.btn_digitize_points.setChecked(False)
            
            QMessageBox.information(self, "Success", "Project cleared successfully!")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to clear project: {str(e)}")

    def activate_start_geo_tool(self):
        """Activate map tool for selecting start point geographic coordinates"""
        self._activate_geo_coordinate_tool('start')
        
    def activate_end_geo_tool(self):
        """Activate map tool for selecting end point geographic coordinates"""
        self._activate_geo_coordinate_tool('end')
        
    def _activate_geo_coordinate_tool(self, point_type):
        """Activate the geographic coordinate selection map tool"""
        try:
            # Get the map canvas
            canvas = self.iface.mapCanvas()
            if not canvas:
                QMessageBox.warning(self, "Error", "No map canvas available")
                return
            
            # Check current CRS and warn if not WGS84
            map_crs = canvas.mapSettings().destinationCrs()
            wgs84_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            
            if map_crs != wgs84_crs:
                # Check if transformation is possible
                transform = QgsCoordinateTransform(map_crs, wgs84_crs, QgsProject.instance())
                if not transform.isValid():
                    QMessageBox.warning(
                        self, "CRS Warning", 
                        f"Cannot transform coordinates from {map_crs.authid()} to WGS84.\n"
                        f"Please ensure your map is in a supported coordinate system."
                    )
                    return
                else:
                    # Show info about transformation
                    reply = QMessageBox.question(
                        self, "CRS Notice", 
                        f"The map is currently in {map_crs.authid()}, not WGS84.\n"
                        f"Coordinates will be automatically transformed to WGS84.\n\n"
                        f"Continue with map clicking?",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.Yes
                    )
                    if reply != QMessageBox.Yes:
                        return
            
            # Store the current map tool to restore later
            self.previous_map_tool = canvas.mapTool()
            
            # Create callback function for this point type
            def coordinate_callback(lon, lat, error):
                if error:
                    QMessageBox.warning(self, "Coordinate Error", error)
                elif lon is not None and lat is not None:
                    # Set the coordinates in the appropriate spinboxes
                    if point_type == 'start':
                        self.spin_start_lon.setValue(lon)
                        self.spin_start_lat.setValue(lat)
                        self.iface.messageBar().pushMessage(
                            "CrossSectionDigitizer", 
                            f"Start point set to: {lon:.6f}, {lat:.6f}", 
                            level=3, duration=3
                        )
                    elif point_type == 'end':
                        self.spin_end_lon.setValue(lon)
                        self.spin_end_lat.setValue(lat)
                        self.iface.messageBar().pushMessage(
                            "CrossSectionDigitizer", 
                            f"End point set to: {lon:.6f}, {lat:.6f}", 
                            level=3, duration=3
                        )
                
                # Restore the previous map tool
                if self.previous_map_tool:
                    canvas.setMapTool(self.previous_map_tool)
                else:
                    canvas.unsetMapTool(self.geo_map_tool)
                self.geo_map_tool = None
            
            # Create and activate the map tool
            self.geo_map_tool = GeographicCoordinateMapTool(canvas, coordinate_callback)
            canvas.setMapTool(self.geo_map_tool)
            
            # Show message to user
            point_name = "start" if point_type == 'start' else "end"
            self.iface.messageBar().pushMessage(
                "CrossSectionDigitizer", 
                f"Click on the map to set the {point_name} point coordinates. Press Escape to cancel.", 
                level=0, duration=5
            )
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to activate map tool: {str(e)}")

    def load_image_file(self, file_path):
        """Helper method to load image from file path"""
        if os.path.exists(file_path):
            # Load image into the viewer using the proper method
            if self.image_viewer.load_image(file_path):
                self.image_path = file_path
                layer_name = os.path.basename(file_path)
                self.label_image_path.setText(f"Loaded: {layer_name}")
                
                # Set up coordinate transformation callback
                self.image_viewer.set_coordinate_transform_callback(self.pixel_to_plot_coords)
                return True
        return False

    def closeEvent(self, event):
        """Handle widget close event"""
        # Clear all markers when closing
        self.clear_all_markers()
        self.closingPlugin.emit()
        event.accept()


EARTH_RAD_KM = 6371.0  # Radius of the Earth in kilometers

def project_x_sec_pts_to_geog(xs, zs, start_pt, end_pt, z_unit='km', depth_pos=False):
    az = azimuth(start_pt[0],
                 start_pt[1],
                 end_pt[0],
                 end_pt[1])

    z_scale = 1000.0 if z_unit=='km' else 1.0
    if depth_pos:
        z_scale *= -1

    proj_pts = []
    for i, x in enumerate(xs):
        lon, lat = terminal_coords_from_bearing_dist(
            start_pt[0], start_pt[1], az, x)
        depth = zs[i] * z_scale
        proj_pts.append((lon, lat, depth))
    
    return proj_pts

        
def terminal_coords_from_bearing_dist(lon1: float, lat1: float, bearing, dist):
    ang_dist = dist / EARTH_RAD_KM
    lat1 = math.radians(lat1)
    lon1 = math.radians(lon1)
    bearing = math.radians(bearing)

    lat2 = math.asin(
        math.sin(lat1) * math.cos(ang_dist)
        + math.cos(lat1) * math.sin(ang_dist) * math.cos(bearing)
    )
    lon2 = lon1 + math.atan2(
        math.sin(bearing) * math.sin(ang_dist) * math.cos(lat1),
        math.cos(ang_dist) - math.sin(lat1) * math.sin(lat2),
    )

    return math.degrees(lon2), math.degrees(lat2)


def azimuth(lon_0: float, lat_0: float, lon_1, lat_1):
    r_lon_0 = math.radians(lon_0)
    r_lat_0 = math.radians(lat_0)
    r_lon_1 = math.radians(lon_1)
    r_lat_1 = math.radians(lat_1)

    dlon = r_lon_1 - r_lon_0
    y = math.sin(dlon) * math.cos(r_lat_1)

    x = math.cos(r_lat_0) * math.sin(r_lat_1) - math.sin(r_lat_0) * math.cos(
        r_lat_1
    ) * math.cos(r_lon_1 - r_lon_0)
    azimuth = math.degrees(math.atan2(y, x))

    return azimuth